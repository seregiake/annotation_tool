{"ast":null,"code":"var _jsxFileName = \"/Users/serenagiachetti/Desktop/projects/annotation_tool/frontend/src/components/ColorCanvas.js\";\nimport React, { Component } from 'react';\n\nclass ColorCanvas extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      drawingAreaX: 0,\n      drawingAreaY: 0,\n      canvasWidth: 0,\n      canvasHeight: 0,\n      mask: [],\n      clusterID: 0,\n      clusterList: [],\n      pointList: [],\n      draggedPointList: [],\n      draggedMaskPointList: [],\n      mouseDrag: false,\n      curColor: [255, 0, 0],\n      outlineColor: [0, 0, 0, 127]\n    };\n    this.floodFill = this.floodFill.bind(this);\n    this.getMousePos = this.getMousePos.bind(this);\n  }\n\n  componentDidMount() {\n    this.updateCanvas();\n  }\n\n  componentDidUpdate() {\n    this.updateCanvas();\n  }\n\n  updateCanvas() {\n    const canvas = this.refs.top;\n    const context = canvas.getContext('2d');\n    const {\n      mask\n    } = this.props;\n    const {\n      boundaries,\n      size,\n      color\n    } = this.props; //console.log(size);\n    // eslint-disable-next-line\n\n    if (boundaries != undefined && size != undefined && color != undefined) {\n      context.canvas.width = size[0];\n      context.canvas.height = size[1];\n      context.clearRect(0, 0, size[0], size[1]); // draw children “components”\n      //outline({context, boundaries, size, color});\n    } // eslint-disable-next-line\n\n    /*\n    if (mask != undefined && size != undefined && color != undefined){\n        context.canvas.width = size[0];\n        context.canvas.height = size[1];\n        //context.clearRect(0,0, size[0], size[1]);\n         // draw children “components”\n        // crea colorImage\n        // fai get delle annotazioni esistenti\n        // e disegnale\n         //this.createColorImage();\n        } */\n\n  }\n\n  createColorImage() {\n    const {\n      size,\n      mask,\n      color\n    } = this.props;\n    const canvas = this.refs.top;\n    const context = canvas.getContext('2d');\n    let mask_matrix = JSON.parse(mask); // console.log(outline_matrix[0][0]);\n\n    let colorLayerData = context.getImageData(0, 0, canvas.width, canvas.width);\n    let colorImage = colorLayerData.data; // scroll the matrix with boundaries to create the outline image\n    // TODO: colora in base alle annotations\n    // draw the outline layer in the 3° canvas\n\n    context.putImageData(colorLayerData, 0, 0);\n  }\n\n  clickMouse(event) {\n    const canvas = this.refs.top;\n    const context = canvas.getContext('2d');\n    let colorLayerData = context.getImageData(0, 0, canvas.width, canvas.width);\n    let colorImage = colorLayerData.data; // Update the canvas with the new data\n\n    let [x, y] = this.getMousePos(event);\n    console.log(\"x: \" + x + \", y: \" + y);\n    this.paintAt(x, y, colorImage);\n    context.putImageData(colorLayerData, 0, 0);\n  }\n\n  getMousePos(e) {\n    const {\n      size\n    } = this.props;\n    let color_canvas = this.refs.top;\n    let drawingAreaX = color_canvas.getBoundingClientRect().left;\n    let drawingAreaY = color_canvas.getBoundingClientRect().top;\n    this.setState(prevState => {\n      return {\n        drawingAreaX: drawingAreaX,\n        drawingAreaY: drawingAreaY,\n        canvasWidth: size[0],\n        canvasHeight: size[1]\n      };\n    });\n    console.log(this.state); // mouse click coordinates on the canvas rounded to manage float case\n\n    let mouseX = Math.round(e.pageX - document.body.scrollLeft - document.documentElement.scrollLeft - drawingAreaX),\n        mouseY = Math.round(e.pageY - document.body.scrollTop - document.documentElement.scrollTop - drawingAreaY);\n    return [mouseX, mouseY];\n  }\n\n  dragStart(event) {//TODO\n  }\n\n  dragOver(event) {//TODO\n  }\n\n  dragEnd(event) {//TODO\n  }\n\n  paintAt(startX, startY, colorImage) {\n    const {\n      size,\n      mask\n    } = this.props;\n    this.setState({\n      canvasWidth: size[0],\n      canvasHeight: size[1]\n    });\n    let mask_matrix = JSON.parse(mask);\n    let clusterList = this.state.clusterList;\n    let pointList = this.state.pointList; // takes pixel RGBA color\n\n    let pixelPos = (startY * size[0] + startX) * 4,\n        r = colorImage[pixelPos],\n        g = colorImage[pixelPos + 1],\n        b = colorImage[pixelPos + 2],\n        a = colorImage[pixelPos + 3];\n    console.log('r: ' + r + 'g: ' + g + 'b: ' + b + 'a: ' + a);\n    /*\n    // return if you try to recolor the area with the same color and the same opacity\n    if (r == color[0] && g == color[1] && b == color[2] && a == color[3]){\n         this.floodFill(startX, startY, r, g, b, a, [0, 0, 0, 0], mask_matrix, colorImage);\n        this.redraw();\n         // delete the element from clusterList and pointList\n         clusterList.splice( clusterList.indexOf(mask[startY][startX]), 1 );\n        pointList.splice( clusterList.indexOf(mask[startY][startX]), 1);\n         this.setState(prevState =>{\n            return {\n                clusterList: clusterList,\n                pointList: pointList\n            }\n        });\n         return\n    }\n     */\n    // call floodFill method and pass to it initial (x,y) and initial RGBA of the pixel clicked\n\n    this.floodFill(startX, startY, r, g, b, a, [0, 0, 255, 255], mask_matrix, colorImage); //this.redraw();\n\n    /*\n     clusterList.push(mask[startY][startX]);\n    pointList.push([startX, startY]);\n     this.setState(prevState =>{\n        return {\n            clusterList: clusterList,\n            pointList: pointList\n        }\n    })\n      */\n  }\n\n  floodFill(startX, startY, startR, startG, startB, startA, newColor, mask, colorImage) {\n    const {\n      size\n    } = this.props;\n    let newPos,\n        x,\n        y,\n        pixelPos,\n        reachLeft = false,\n        reachRight = false,\n        canvasBoundLeft = 0,\n        canvasBoundTop = 0,\n        canvasBoundRight = canvasBoundLeft + size[0] - 1,\n        canvasBoundBottom = canvasBoundTop + size[1] - 1,\n        pixelStack = [[startX, startY]],\n        cluster_id = mask[startY][startX];\n    this.setState({\n      clusterID: mask[startY][startX]\n    });\n    console.log('CLUSTER ID: ' + mask[startY][startX]);\n    console.log(pixelStack);\n\n    while (pixelStack.length) {\n      console.log(pixelStack.length);\n      newPos = pixelStack.pop();\n      console.log(pixelStack);\n      console.log(newPos);\n      x = newPos[0];\n      y = newPos[1]; // takes current pixel position\n\n      pixelPos = (y * size[0] + x) * 4;\n      console.log(size[0]);\n      console.log('pixelPos: ' + pixelPos);\n      console.log('PRIMO WHILE');\n      console.log('canvasBoundTop: ' + canvasBoundTop); // go up inside the canvas until initialColor matches\n\n      while (y >= canvasBoundTop && this.matchInitialColor(pixelPos, x, y, startR, startG, startB, startA, newColor, colorImage, mask, cluster_id)) {\n        console.log('y: ' + y);\n        y -= 1;\n        pixelPos -= size[0] * 4;\n      }\n\n      console.log('y: ' + y);\n      pixelPos += size[0] * 4;\n      y += 1;\n      reachLeft = false;\n      reachRight = false;\n      console.log('y: ' + y);\n      console.log('SECONDO WHILE');\n      console.log('canvasBoundBottom' + canvasBoundBottom); // go down inside the canvas until initialColor matches\n\n      while (y <= canvasBoundBottom && this.matchInitialColor(pixelPos, x, y, startR, startG, startB, startA, newColor, colorImage, mask, cluster_id)) {\n        //y += 1;\n        console.log('y' + y);\n        this.colorPixel(pixelPos, newColor[0], newColor[1], newColor[2], newColor[3], colorImage);\n\n        if (x > canvasBoundLeft) {\n          //check left side pixel\n          if (this.matchInitialColor(pixelPos - 4, x - 1, y, startR, startG, startB, startA, newColor, colorImage, mask, cluster_id)) {\n            if (!reachLeft) {\n              //aggiungi pixel allo stack\n              pixelStack.push([x - 1, y]);\n              reachLeft = true;\n              console.log('pixelStack: ' + pixelStack);\n              console.log('reachLeft: ' + reachLeft);\n            }\n          } else if (reachLeft) {\n            reachLeft = false;\n          }\n        }\n        /*\n        if (x < canvasBoundRight) { //check right side pixel\n            if (this.matchInitialColor(pixelPos + 4, x + 1, y, startR, startG, startB, startA, newColor, colorImage, mask, cluster_id)) {\n                if (!reachRight) {\n                    //aggiungi pixel allo stack\n                    pixelStack.push([x + 1, y]);\n                    reachRight = true;\n                    console.log('pixelStack: ' + pixelStack);\n                    console.log('reachRight: ' + reachRight);\n                }\n            } else if (reachRight) {\n                reachRight = false;\n            }\n        }\n          */\n\n\n        y += 1;\n        pixelPos += size[0] * 4;\n      }\n    }\n  }\n\n  redraw() {//console.log(\"disegna\");\n  }\n\n  matchInitialColor(pixelPos, x, y, startR, startG, startB, startA, newColor, colorImage, mask, cluster_id) {\n    console.log('matchInitialColor');\n    let different_cluster = false; // console.log(mask[y][x]);\n    //console.log(mask[y][x]);\n    // eslint-disable-next-line\n\n    if (mask[y][x] != cluster_id) {\n      console.log('clusterID:' + cluster_id);\n      console.log('mask cluster:' + mask[y][x]);\n      different_cluster = true;\n    } // check if current pixel is in outline image and has different cluster_id\n\n\n    if (this.matchOutlineBorder(x, y) && different_cluster) {\n      console.log('PRIMO RETURN');\n      return false;\n    }\n\n    let r = colorImage[pixelPos],\n        g = colorImage[pixelPos + 1],\n        b = colorImage[pixelPos + 2],\n        a = colorImage[pixelPos + 3]; // If the current pixel matches the clicked color\n    // eslint-disable-next-line\n\n    /*\n    if (r == startR && g == startG && b == startB && a == startA){\n        return true;\n    }\n      */\n    // If current pixel color is already colored with new color and opacity\n    // eslint-disable-next-line\n\n    if (r == newColor[0] && g == newColor[1] && b == newColor[2] && a == newColor[3]) {\n      console.log('SECONDO RETURN');\n      return false;\n    }\n\n    console.log('ULTIMO RETURN');\n    return true;\n  }\n\n  colorPixel(pixelPos, r, g, b, a, colorImage) {\n    console.log('COLOR PIXEL');\n    colorImage[pixelPos] = 0;\n    colorImage[pixelPos + 1] = 0;\n    colorImage[pixelPos + 2] = 255;\n    colorImage[pixelPos + 3] = a !== undefined ? a : 255;\n  }\n\n  matchOutlineBorder(x, y) {\n    const {\n      boundaries\n    } = this.props;\n    let outline_matrix = JSON.parse(boundaries);\n    let pixel = outline_matrix[y][x];\n    return String(pixel[0]) === '0';\n    /*\n    let r = outlineImage[pixelPos],\n        g = outlineImage[pixelPos + 1],\n        b = outlineImage[pixelPos + 2],\n        a = outlineImage[pixelPos + 3];\n     return (r === outlineColor[0] && g === outlineColor[1] && b === outlineColor[2] && a == outlineColor[3] );\n     */\n  }\n\n  render() {\n    return React.createElement(\"canvas\", {\n      id: \"color\",\n      ref: \"top\",\n      style: {\n        zIndex: 3,\n        position: 'absolute'\n      },\n      onMouseDown: event => this.clickMouse(event),\n      onDragStart: event => this.dragStart(event),\n      onDragOver: event => this.dragOver(event),\n      onDragEnd: event => this.dragEnd(event),\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 405\n      },\n      __self: this\n    }, \"Sorry, your browser doesn't support the <canvas> element.\");\n  }\n\n}\n\nexport default ColorCanvas;\n\nfunction outline(props) {\n  const {\n    context,\n    size,\n    boundaries,\n    color\n  } = props;\n  let outline_matrix = JSON.parse(boundaries); // console.log(outline_matrix[0][0]);\n\n  let outlineLayerData = context.createImageData(size[0], size[1]);\n  let outlineImage = outlineLayerData.data; // scroll the matrix with boundaries to create the outline image\n\n  let len = outlineLayerData.data.length; // console.log(len);\n\n  let col = 0,\n      row = 0;\n  let pixel = [];\n\n  for (let i = 0; i < len && row < size[1]; i += 4) {\n    pixel = outline_matrix[row][col]; // console.log(\"pixel: \" + pixel);\n\n    if (String(pixel[0]) === '1') {\n      outlineImage[i] = color[0]; // r\n\n      outlineImage[i + 1] = color[1]; // g\n\n      outlineImage[i + 2] = color[2]; // b\n\n      outlineImage[i + 3] = color[3]; // a\n    }\n\n    if (col === size[0] - 1) {\n      row++;\n      col = 0;\n    } else {\n      col++;\n    }\n  } // draw the outline layer in the 3° canvas\n\n\n  context.putImageData(outlineLayerData, 0, 0);\n}","map":{"version":3,"sources":["/Users/serenagiachetti/Desktop/projects/annotation_tool/frontend/src/components/ColorCanvas.js"],"names":["React","Component","ColorCanvas","constructor","props","state","drawingAreaX","drawingAreaY","canvasWidth","canvasHeight","mask","clusterID","clusterList","pointList","draggedPointList","draggedMaskPointList","mouseDrag","curColor","outlineColor","floodFill","bind","getMousePos","componentDidMount","updateCanvas","componentDidUpdate","canvas","refs","top","context","getContext","boundaries","size","color","undefined","width","height","clearRect","createColorImage","mask_matrix","JSON","parse","colorLayerData","getImageData","colorImage","data","putImageData","clickMouse","event","x","y","console","log","paintAt","e","color_canvas","getBoundingClientRect","left","setState","prevState","mouseX","Math","round","pageX","document","body","scrollLeft","documentElement","mouseY","pageY","scrollTop","dragStart","dragOver","dragEnd","startX","startY","pixelPos","r","g","b","a","startR","startG","startB","startA","newColor","newPos","reachLeft","reachRight","canvasBoundLeft","canvasBoundTop","canvasBoundRight","canvasBoundBottom","pixelStack","cluster_id","length","pop","matchInitialColor","colorPixel","push","redraw","different_cluster","matchOutlineBorder","outline_matrix","pixel","String","render","zIndex","position","outline","outlineLayerData","createImageData","outlineImage","len","col","row","i"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\nclass ColorCanvas extends Component {\n\n    constructor (props){\n        super(props);\n        this.state = {\n            drawingAreaX: 0,\n            drawingAreaY: 0,\n            canvasWidth: 0,\n            canvasHeight: 0,\n            mask: [],\n            clusterID: 0,\n            clusterList: [],\n            pointList: [],\n            draggedPointList: [],\n            draggedMaskPointList: [],\n            mouseDrag: false,\n            curColor: [255, 0, 0],\n            outlineColor: [0, 0, 0, 127],\n\n        }\n        this.floodFill = this.floodFill.bind(this);\n        this.getMousePos = this.getMousePos.bind(this);\n\n    }\n\n    componentDidMount() {\n        this.updateCanvas();\n    }\n\n    componentDidUpdate() {\n        this.updateCanvas();\n    }\n\n    updateCanvas() {\n        const canvas = this.refs.top;\n        const context = canvas.getContext('2d');\n        const { mask } = this.props;\n\n        const { boundaries, size, color } = this.props;\n\n        //console.log(size);\n        // eslint-disable-next-line\n        if (boundaries != undefined && size != undefined && color != undefined){\n            context.canvas.width = size[0];\n            context.canvas.height = size[1];\n            context.clearRect(0,0, size[0], size[1]);\n\n            // draw children “components”\n            //outline({context, boundaries, size, color});\n\n        }\n\n        // eslint-disable-next-line\n        /*\n        if (mask != undefined && size != undefined && color != undefined){\n            context.canvas.width = size[0];\n            context.canvas.height = size[1];\n            //context.clearRect(0,0, size[0], size[1]);\n\n            // draw children “components”\n            // crea colorImage\n            // fai get delle annotazioni esistenti\n            // e disegnale\n\n            //this.createColorImage();\n\n\n\n\n        } */\n    }\n\n    createColorImage() {\n        const { size, mask, color } = this.props;\n        const canvas = this.refs.top;\n        const context = canvas.getContext('2d');\n\n        let mask_matrix = JSON.parse(mask);\n\n        // console.log(outline_matrix[0][0]);\n\n        let colorLayerData = context.getImageData(0, 0, canvas.width, canvas.width);\n\n        let colorImage = colorLayerData.data;\n        // scroll the matrix with boundaries to create the outline image\n\n        // TODO: colora in base alle annotations\n\n\n        // draw the outline layer in the 3° canvas\n        context.putImageData(colorLayerData, 0, 0);\n\n\n    }\n\n\n    clickMouse(event){\n        const canvas = this.refs.top;\n        const context = canvas.getContext('2d');\n        let colorLayerData = context.getImageData(0, 0, canvas.width, canvas.width);\n        let colorImage = colorLayerData.data;\n\n\n        // Update the canvas with the new data\n\n\n        let [x, y] = this.getMousePos(event);\n        console.log(\"x: \" + x + \", y: \" + y);\n        this.paintAt(x, y, colorImage);\n\n        context.putImageData(colorLayerData, 0, 0);\n\n    }\n\n    getMousePos(e){\n        const {  size } = this.props;\n        let color_canvas = this.refs.top;\n        let drawingAreaX = color_canvas.getBoundingClientRect().left;\n        let drawingAreaY = color_canvas.getBoundingClientRect().top;\n\n        this.setState(prevState => {\n           return {\n                drawingAreaX: drawingAreaX,\n                drawingAreaY: drawingAreaY,\n                canvasWidth: size[0],\n                canvasHeight: size[1],\n           }\n        });\n\n        console.log(this.state);\n\n        // mouse click coordinates on the canvas rounded to manage float case\n        let mouseX = Math.round(e.pageX - document.body.scrollLeft - document.documentElement.scrollLeft - drawingAreaX),\n            mouseY = Math.round(e.pageY - document.body.scrollTop - document.documentElement.scrollTop - drawingAreaY);\n\n        return [mouseX, mouseY];\n\n    }\n\n    dragStart(event){\n        //TODO\n    }\n\n    dragOver(event){\n        //TODO\n    }\n\n    dragEnd(event){\n        //TODO\n    }\n\n    paintAt(startX, startY, colorImage){\n        const { size, mask } = this.props;\n        this.setState({\n            canvasWidth: size[0],\n            canvasHeight: size[1]\n        });\n\n        let mask_matrix = JSON.parse(mask);\n\n        let clusterList = this.state.clusterList;\n        let pointList = this.state.pointList;\n\n        // takes pixel RGBA color\n        let pixelPos = (startY * size[0] + startX) * 4,\n            r = colorImage[pixelPos],\n            g = colorImage[pixelPos + 1],\n            b = colorImage[pixelPos + 2],\n            a = colorImage[pixelPos + 3];\n\n        console.log('r: ' + r + 'g: ' + g + 'b: ' + b + 'a: ' + a);\n\n\n        /*\n        // return if you try to recolor the area with the same color and the same opacity\n        if (r == color[0] && g == color[1] && b == color[2] && a == color[3]){\n\n            this.floodFill(startX, startY, r, g, b, a, [0, 0, 0, 0], mask_matrix, colorImage);\n            this.redraw();\n\n            // delete the element from clusterList and pointList\n\n            clusterList.splice( clusterList.indexOf(mask[startY][startX]), 1 );\n            pointList.splice( clusterList.indexOf(mask[startY][startX]), 1);\n\n            this.setState(prevState =>{\n                return {\n                    clusterList: clusterList,\n                    pointList: pointList\n                }\n            });\n\n            return\n        }\n\n        */\n\n        // call floodFill method and pass to it initial (x,y) and initial RGBA of the pixel clicked\n        this.floodFill(startX, startY, r, g, b, a, [0, 0, 255, 255], mask_matrix, colorImage);\n        //this.redraw();\n\n        /*\n\n        clusterList.push(mask[startY][startX]);\n        pointList.push([startX, startY]);\n\n        this.setState(prevState =>{\n            return {\n                clusterList: clusterList,\n                pointList: pointList\n            }\n        })\n\n         */\n\n\n\n    }\n\n    floodFill(startX, startY, startR, startG, startB, startA, newColor, mask, colorImage){\n        const { size } = this.props;\n\n        let newPos,\n            x,\n            y,\n            pixelPos,\n            reachLeft = false,\n            reachRight = false,\n            canvasBoundLeft = 0,\n            canvasBoundTop = 0,\n            canvasBoundRight = canvasBoundLeft + size[0] - 1,\n            canvasBoundBottom = canvasBoundTop + size[1] - 1,\n            pixelStack = [[startX, startY]],\n            cluster_id = mask[startY][startX];\n\n\n        this.setState({\n                clusterID: mask[startY][startX],\n            }\n        );\n        console.log('CLUSTER ID: ' + mask[startY][startX]);\n        console.log(pixelStack);\n\n        while (pixelStack.length) {\n\n            console.log(pixelStack.length);\n\n            newPos = pixelStack.pop();\n            console.log(pixelStack);\n            console.log(newPos);\n            x = newPos[0];\n            y = newPos[1];\n\n            // takes current pixel position\n            pixelPos = (y * size[0] + x) * 4;\n            console.log(size[0]);\n            console.log('pixelPos: ' + pixelPos);\n\n            console.log('PRIMO WHILE');\n            console.log('canvasBoundTop: ' + canvasBoundTop);\n            // go up inside the canvas until initialColor matches\n            while (y >= canvasBoundTop && this.matchInitialColor(pixelPos, x, y, startR, startG, startB, startA, newColor, colorImage, mask, cluster_id)) {\n                console.log('y: ' + y);\n                y -= 1;\n                pixelPos -= size[0] * 4;\n            }\n            console.log('y: ' + y);\n\n            pixelPos += size[0] * 4;\n            y += 1;\n            reachLeft = false;\n            reachRight = false;\n\n            console.log('y: ' + y);\n            console.log('SECONDO WHILE');\n            console.log('canvasBoundBottom' + canvasBoundBottom);\n            // go down inside the canvas until initialColor matches\n            while (y <= canvasBoundBottom && this.matchInitialColor(pixelPos, x, y, startR, startG, startB, startA, newColor, colorImage, mask, cluster_id)) {\n                //y += 1;\n                console.log('y' + y);\n                this.colorPixel(pixelPos, newColor[0], newColor[1], newColor[2], newColor[3], colorImage);\n\n\n                if (x > canvasBoundLeft) { //check left side pixel\n                    if (this.matchInitialColor(pixelPos - 4, x - 1, y, startR, startG, startB, startA, newColor, colorImage, mask, cluster_id)) {\n                        if (!reachLeft) {\n                            //aggiungi pixel allo stack\n                            pixelStack.push([x - 1, y]);\n                            reachLeft = true;\n                            console.log('pixelStack: ' + pixelStack);\n                            console.log('reachLeft: ' + reachLeft);\n                        }\n                    } else if (reachLeft) {\n                        reachLeft = false;\n                    }\n                }\n\n                /*\n                if (x < canvasBoundRight) { //check right side pixel\n                    if (this.matchInitialColor(pixelPos + 4, x + 1, y, startR, startG, startB, startA, newColor, colorImage, mask, cluster_id)) {\n                        if (!reachRight) {\n                            //aggiungi pixel allo stack\n                            pixelStack.push([x + 1, y]);\n                            reachRight = true;\n                            console.log('pixelStack: ' + pixelStack);\n                            console.log('reachRight: ' + reachRight);\n                        }\n                    } else if (reachRight) {\n                        reachRight = false;\n                    }\n                }\n\n                 */\n\n\n                y += 1;\n                pixelPos += size[0] * 4;\n\n            }\n\n        }\n\n\n    }\n\n    redraw(){\n        //console.log(\"disegna\");\n    }\n\n    matchInitialColor(pixelPos, x, y, startR, startG, startB, startA, newColor, colorImage, mask, cluster_id){\n        console.log('matchInitialColor');\n        let different_cluster = false;\n        // console.log(mask[y][x]);\n        //console.log(mask[y][x]);\n        // eslint-disable-next-line\n        if(mask[y][x] != cluster_id){\n            console.log( 'clusterID:' + cluster_id);\n            console.log('mask cluster:' +mask[y][x]);\n            different_cluster = true;\n        }\n\n        // check if current pixel is in outline image and has different cluster_id\n        if (this.matchOutlineBorder(x,y) && different_cluster){\n            console.log('PRIMO RETURN');\n            return false;\n        }\n\n\n        let r = colorImage[pixelPos],\n            g = colorImage[pixelPos + 1],\n            b = colorImage[pixelPos + 2],\n            a = colorImage[pixelPos + 3];\n\n        // If the current pixel matches the clicked color\n        // eslint-disable-next-line\n        /*\n        if (r == startR && g == startG && b == startB && a == startA){\n            return true;\n        }\n\n         */\n\n        // If current pixel color is already colored with new color and opacity\n        // eslint-disable-next-line\n        if (r == newColor[0] && g == newColor[1] && b == newColor[2] && a == newColor[3] ) {\n            console.log('SECONDO RETURN');\n            return false;\n        }\n\n        console.log('ULTIMO RETURN');\n        return true;\n    }\n\n    colorPixel(pixelPos, r, g, b, a, colorImage) {\n        console.log('COLOR PIXEL');\n        colorImage[pixelPos] = 0;\n        colorImage[pixelPos + 1] = 0;\n        colorImage[pixelPos + 2] = 255;\n        colorImage[pixelPos + 3] = a !== undefined ? a : 255;\n    }\n\n    matchOutlineBorder(x,y){\n\n        const { boundaries } = this.props;\n        let outline_matrix = JSON.parse(boundaries);\n\n        let pixel = outline_matrix[y][x];\n\n        return (String(pixel[0]) === '0');\n\n        /*\n        let r = outlineImage[pixelPos],\n            g = outlineImage[pixelPos + 1],\n            b = outlineImage[pixelPos + 2],\n            a = outlineImage[pixelPos + 3];\n\n        return (r === outlineColor[0] && g === outlineColor[1] && b === outlineColor[2] && a == outlineColor[3] );\n         */\n\n    }\n\n    render(){\n        return(\n            <canvas id=\"color\"\n                    ref=\"top\"\n                    style={{ zIndex: 3, position:'absolute'}}\n                    onMouseDown={(event) => this.clickMouse(event)}\n                    onDragStart={(event) => this.dragStart(event)}\n                    onDragOver={(event) => this.dragOver(event)}\n                    onDragEnd={(event) => this.dragEnd(event)} >\n                Sorry, your browser doesn't support the &lt;canvas&gt; element. \n            </canvas> \n        )\n    }\n}\nexport default ColorCanvas;\n\nfunction outline(props) {\n    const {context, size, boundaries, color} = props;\n    let outline_matrix = JSON.parse(boundaries);\n\n    // console.log(outline_matrix[0][0]);\n\n    let outlineLayerData = context.createImageData(size[0], size[1]);\n    let outlineImage = outlineLayerData.data;\n    // scroll the matrix with boundaries to create the outline image\n    let len = outlineLayerData.data.length;\n    // console.log(len);\n    let col = 0, row = 0;\n    let pixel = [];\n    for (let i = 0; i < len && row < size[1]; i += 4) {\n        pixel = outline_matrix[row][col];\n        // console.log(\"pixel: \" + pixel);\n        if (String(pixel[0]) === '1') {\n            outlineImage[i] = color[0];       // r\n            outlineImage[i + 1] = color[1];   // g\n            outlineImage[i + 2] = color[2];   // b\n            outlineImage[i + 3] = color[3];   // a\n        }\n        if (col === size[0] - 1) {\n            row++;\n            col = 0;\n        } else {\n            col++;\n        }\n\n    }\n\n    // draw the outline layer in the 3° canvas\n    context.putImageData(outlineLayerData, 0, 0);\n\n\n}\n\n"]},"metadata":{},"sourceType":"module"}