{"ast":null,"code":"var _jsxFileName = \"/Users/serenagiachetti/Desktop/projects/annotation_tool/frontend/src/components/ColorCanvas.js\";\nimport React, { Component } from 'react';\n\nclass ColorCanvas extends Component {\n  constructor(props) {\n    super(props);\n    this.canvasRef = React.createRef();\n    this.state = {\n      drawingAreaX: 0,\n      drawingAreaY: 0,\n      canvasWidth: 0,\n      canvasHeight: 0,\n      mask: [],\n      clusterID: 0,\n      clusterList: [],\n      pointList: [],\n      draggedPointList: [],\n      draggedMaskPointList: [],\n      mouseDrag: false,\n      curColor: [255, 0, 0],\n      outlineColor: [0, 0, 0, 127]\n    };\n  }\n\n  componentDidMount() {\n    this.updateCanvas();\n  }\n\n  componentDidUpdate() {\n    this.updateCanvas();\n  }\n\n  updateCanvas() {\n    const canvas = this.canvasRef.current;\n    const context = canvas.getContext('2d');\n    const {\n      mask,\n      size,\n      color\n    } = this.props; //console.log(size);\n    // eslint-disable-next-line\n\n    if (mask != undefined && size != undefined && color != undefined) {\n      context.canvas.width = size[0];\n      context.canvas.height = size[1];\n      context.clearRect(0, 0, size[0], size[1]); // draw children “components”\n      // crea colorImage\n      // fai get delle annotazioni esistenti\n      // e disegnale\n\n      createColorImage({\n        context,\n        mask,\n        size,\n        color\n      });\n    }\n  }\n\n  getMousePos(e) {\n    const {\n      size,\n      mask\n    } = this.props;\n    let color_canvas = this.canvasRef.current;\n    let drawingAreaX = color_canvas.getBoundingClientRect().left;\n    let drawingAreaY = color_canvas.getBoundingClientRect().top;\n    this.setState(() => {\n      return {\n        drawingAreaX: drawingAreaX,\n        drawingAreaY: drawingAreaY,\n        canvasWidth: size[0],\n        canvasHeight: size[1],\n        mask: JSON.parse(mask)\n      };\n    });\n    console.log(this.state); // mouse click coordinates on the canvas rounded to manage float case\n\n    let mouseX = Math.round(e.pageX - document.body.scrollLeft - document.documentElement.scrollLeft - drawingAreaX),\n        mouseY = Math.round(e.pageY - document.body.scrollTop - document.documentElement.scrollTop - drawingAreaY);\n    return [mouseX, mouseY];\n  }\n\n  clickMouse(event) {\n    const {\n      mask\n    } = this.props;\n\n    if (mask != undefined) {\n      let [x, y] = this.getMousePos(event);\n      console.log(\"x: \" + x + \", y: \" + y);\n      this.paintAt(x, y);\n    }\n  }\n\n  dragStart(event) {//TODO\n  }\n\n  dragOver(event) {//TODO\n  }\n\n  dragEnd(event) {//TODO\n  }\n\n  paintAt(startX, startY) {\n    const {\n      size,\n      color\n    } = this.props;\n    const canvas = this.canvasRef.current;\n    const context = canvas.getContext('2d'); // eslint-disable-next-line\n\n    if (size != undefined && color != undefined) {\n      let colorImage = context.getImageData(0, 0, size[0], size[1]).data; // takes pixel RGBA color\n\n      let pixelPos = (startY * size[0] + startX) * 4,\n          r = colorImage[pixelPos],\n          g = colorImage[pixelPos + 1],\n          b = colorImage[pixelPos + 2],\n          a = colorImage[pixelPos + 3]; // return if you try to recolor the area with the same color and the same opacity\n\n      if (r == color[0] && g == color[1] && b == color[2] && a == color[3]) {\n        this.floodFill(startX, startY, r, g, b, a, [0, 0, 0, 0], this.state.mask, colorImage);\n        redraw(); // delete the element from clusterList and pointList\n\n        this.setState(prevState => {\n          return {\n            clusterList: prevState.clusterList.splice(prevState.clusterList.indexOf(this.state.mask[startY][startX]), 1),\n            pointList: prevState.pointList.splice(prevState.clusterList.indexOf(this.state.mask[startY][startX]), 1)\n          };\n        });\n        return;\n      } // call floodFill method and pass to it initial (x,y) and initial RGBA of the pixel clicked\n\n\n      this.floodFill(startX, startY, r, g, b, a, color, this.state.mask, colorImage);\n      redraw();\n      this.setState(prevState => {\n        return {\n          clusterList: prevState.clusterList.push(this.state.mask[startY][startX]),\n          pointList: prevState.pointList.push([startX, startY])\n        };\n      });\n    }\n  }\n\n  floodFill(startX, startY, startR, startG, startB, startA, newColor, mask, colorImage) {\n    let newPos,\n        x,\n        y,\n        pixelPos,\n        reachLeft,\n        reachRight,\n        canvasBoundLeft = 0,\n        canvasBoundTop = 0,\n        canvasBoundRight = canvasBoundLeft + this.state.canvasWidth - 1,\n        canvasBoundBottom = canvasBoundTop + this.state.canvasHeight - 1,\n        pixelStack = [[startX, startY]];\n    this.setState(() => {\n      return {\n        clusterID: this.state.mask[startY][startX]\n      };\n    });\n\n    while (pixelStack.length) {\n      newPos = pixelStack.pop();\n      x = newPos[0];\n      y = newPos[1]; // takes current pixel position\n\n      pixelPos = (y * this.state.canvasWidth + x) * 4; // go up inside the canvas until initialColor matches\n\n      while (y >= canvasBoundTop && this.matchInitialColor(pixelPos, x, y, startR, startG, startB, startA, newColor, colorImage, mask)) {\n        y -= 1;\n        pixelPos -= this.state.canvasWidth * 4;\n      }\n\n      pixelPos += this.state.canvasWidth * 4;\n      y += 1;\n      reachLeft = false;\n      reachRight = false; // go down inside the canvas until initialColor matches\n\n      while (y <= canvasBoundBottom && this.matchInitialColor(pixelPos, x, y, startR, startG, startB, startA, newColor, colorImage, mask)) {\n        //y += 1;\n        this.colorPixel(pixelPos, newColor[0], newColor[1], newColor[2], newColor[3], colorImage);\n\n        if (x > canvasBoundLeft) {\n          //check left side pixel\n          if (this.matchInitialColor(pixelPos - 4, x - 1, y, startR, startG, startB, startA, newColor, colorImage, mask)) {\n            if (!reachLeft) {\n              //aggiungi pixel allo stack\n              pixelStack.push([x - 1, y]);\n              reachLeft = true;\n            }\n          } else if (reachLeft) {\n            reachLeft = false;\n          }\n        }\n\n        if (x < canvasBoundRight) {\n          //check right side pixel\n          if (this.matchInitialColor(pixelPos + 4, x + 1, y, startR, startG, startB, startA, newColor, colorImage, mask)) {\n            if (!reachRight) {\n              //aggiungi pixel allo stack\n              pixelStack.push([x + 1, y]);\n              reachRight = true;\n            }\n          } else if (reachRight) {\n            reachRight = false;\n          }\n        }\n\n        y += 1;\n        pixelPos += this.state.canvasWidth * 4;\n      }\n    }\n  }\n\n  matchInitialColor(pixelPos, x, y, startR, startG, startB, startA, newColor, colorImage, mask) {\n    let different_cluster = false;\n    console.log(mask[y][x]);\n    console.log(this.state.mask[y][x]); // eslint-disable-next-line\n\n    if (this.state.mask[y][x] != this.state.clusterID) {\n      //console.log(mask[y][x]);\n      different_cluster = true;\n    } // check if current pixel is in outline image and has different cluster_id\n\n\n    if (this.matchOutlineBorder(pixelPos) && different_cluster) {\n      return false;\n    }\n\n    let r = colorImage[pixelPos],\n        g = colorImage[pixelPos + 1],\n        b = colorImage[pixelPos + 2],\n        a = colorImage[pixelPos + 3]; // If the current pixel matches the clicked color\n    // eslint-disable-next-line\n\n    if (r == startR && g == startG && b == startB && a == startA) {\n      return true;\n    } // If current pixel color is already colored with new color and opacity\n    // eslint-disable-next-line\n\n\n    if (r == newColor[0] && g == newColor[1] && b == newColor[2] && a == newColor[3]) {\n      return false;\n    }\n\n    return true;\n  }\n\n  colorPixel(pixelPos, r, g, b, a, colorImage) {\n    colorImage[pixelPos] = r;\n    colorImage[pixelPos + 1] = g;\n    colorImage[pixelPos + 2] = b;\n    colorImage[pixelPos + 3] = a !== undefined ? a : 255;\n  }\n\n  matchOutlineBorder(pixelPos) {\n    const {\n      boundaries\n    } = this.props;\n    let outline_matrix = JSON.parse(boundaries);\n    let pixel = outline_matrix[pixelPos];\n    return String(pixel[0]) === '0';\n    /*\n    let r = outlineImage[pixelPos],\n        g = outlineImage[pixelPos + 1],\n        b = outlineImage[pixelPos + 2],\n        a = outlineImage[pixelPos + 3];\n     return (r === outlineColor[0] && g === outlineColor[1] && b === outlineColor[2] && a == outlineColor[3] );\n     */\n  }\n\n  render() {\n    return React.createElement(\"canvas\", {\n      id: \"color\",\n      ref: this.canvasRef,\n      style: {\n        zIndex: 3,\n        position: 'absolute'\n      },\n      onClick: event => this.clickMouse(event),\n      onDragStart: event => this.dragStart(event),\n      onDragOver: event => this.dragOver(event),\n      onDragEnd: event => this.dragEnd(event),\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 301\n      },\n      __self: this\n    }, \"Sorry, your browser doesn't support the <canvas> element.\");\n  }\n\n}\n\nexport default ColorCanvas;\n\nfunction createColorImage(props) {\n  const {\n    context,\n    size,\n    mask,\n    color\n  } = props;\n  let mask_matrix = JSON.parse(mask); // console.log(outline_matrix[0][0]);\n\n  let colorLayerData = context.createImageData(size[0], size[1]);\n  let colorImage = colorLayerData.data; // scroll the matrix with boundaries to create the outline image\n  // TODO: colora in base alle annotations\n  // draw the outline layer in the 3° canvas\n\n  context.putImageData(colorLayerData, 0, 0);\n}\n\nfunction redraw() {}","map":{"version":3,"sources":["/Users/serenagiachetti/Desktop/projects/annotation_tool/frontend/src/components/ColorCanvas.js"],"names":["React","Component","ColorCanvas","constructor","props","canvasRef","createRef","state","drawingAreaX","drawingAreaY","canvasWidth","canvasHeight","mask","clusterID","clusterList","pointList","draggedPointList","draggedMaskPointList","mouseDrag","curColor","outlineColor","componentDidMount","updateCanvas","componentDidUpdate","canvas","current","context","getContext","size","color","undefined","width","height","clearRect","createColorImage","getMousePos","e","color_canvas","getBoundingClientRect","left","top","setState","JSON","parse","console","log","mouseX","Math","round","pageX","document","body","scrollLeft","documentElement","mouseY","pageY","scrollTop","clickMouse","event","x","y","paintAt","dragStart","dragOver","dragEnd","startX","startY","colorImage","getImageData","data","pixelPos","r","g","b","a","floodFill","redraw","prevState","splice","indexOf","push","startR","startG","startB","startA","newColor","newPos","reachLeft","reachRight","canvasBoundLeft","canvasBoundTop","canvasBoundRight","canvasBoundBottom","pixelStack","length","pop","matchInitialColor","colorPixel","different_cluster","matchOutlineBorder","boundaries","outline_matrix","pixel","String","render","zIndex","position","mask_matrix","colorLayerData","createImageData","putImageData"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\nclass ColorCanvas extends Component {\n\n    constructor (props){\n        super(props);\n        this.canvasRef = React.createRef();\n        this.state = {\n            drawingAreaX: 0,\n            drawingAreaY: 0,\n            canvasWidth: 0,\n            canvasHeight: 0,\n            mask: [],\n            clusterID: 0,\n            clusterList: [],\n            pointList: [],\n            draggedPointList: [],\n            draggedMaskPointList: [],\n            mouseDrag: false,\n            curColor: [255, 0, 0],\n            outlineColor: [0, 0, 0, 127]\n\n        }\n    }\n\n    componentDidMount() {\n        this.updateCanvas();\n    }\n\n    componentDidUpdate() {\n        this.updateCanvas();\n    }\n\n    updateCanvas() {\n        const canvas = this.canvasRef.current;\n        const context = canvas.getContext('2d');\n        const { mask, size, color } = this.props;\n\n        //console.log(size);\n        // eslint-disable-next-line\n        if (mask != undefined && size != undefined && color != undefined){\n            context.canvas.width = size[0];\n            context.canvas.height = size[1];\n            context.clearRect(0,0, size[0], size[1]);\n\n            // draw children “components”\n            // crea colorImage\n            // fai get delle annotazioni esistenti\n            // e disegnale\n            createColorImage({context, mask, size, color});\n\n        }\n    }\n\n    getMousePos(e){\n        const {  size, mask } = this.props;\n           let color_canvas = this.canvasRef.current;\n           let drawingAreaX = color_canvas.getBoundingClientRect().left;\n           let drawingAreaY = color_canvas.getBoundingClientRect().top;\n           this.setState(() =>{\n               return {\n                    drawingAreaX: drawingAreaX,\n                    drawingAreaY: drawingAreaY,\n                    canvasWidth: size[0],\n                    canvasHeight: size[1],\n                    mask: JSON.parse(mask)\n               }\n           });\n\n           console.log(this.state);\n\n           // mouse click coordinates on the canvas rounded to manage float case\n           let mouseX = Math.round(e.pageX - document.body.scrollLeft - document.documentElement.scrollLeft - drawingAreaX),\n                mouseY = Math.round(e.pageY - document.body.scrollTop - document.documentElement.scrollTop - drawingAreaY);\n\n           return [mouseX, mouseY];\n\n    }\n\n    clickMouse(event){\n\n        const { mask } = this.props;\n\n        if(mask != undefined) {\n            let [x, y] = this.getMousePos(event);\n\n            console.log(\"x: \" + x + \", y: \" + y);\n\n            this.paintAt(x, y);\n        }\n\n    }\n\n    dragStart(event){\n        //TODO\n    }\n\n    dragOver(event){\n        //TODO\n    }\n\n    dragEnd(event){\n        //TODO\n    }\n\n    paintAt(startX, startY){\n        const { size, color} = this.props;\n        const canvas = this.canvasRef.current;\n        const context = canvas.getContext('2d');\n\n        // eslint-disable-next-line\n        if(size != undefined && color != undefined){\n\n            let colorImage = context.getImageData(0,0, size[0], size[1]).data;\n\n            // takes pixel RGBA color\n            let pixelPos = (startY * size[0] + startX) * 4,\n                r = colorImage[pixelPos],\n                g = colorImage[pixelPos + 1],\n                b = colorImage[pixelPos + 2],\n                a = colorImage[pixelPos + 3];\n\n            // return if you try to recolor the area with the same color and the same opacity\n            if (r == color[0] && g == color[1] && b == color[2] && a == color[3]){\n\n                this.floodFill(startX, startY, r, g, b, a, [0, 0, 0, 0], this.state.mask, colorImage);\n                redraw();\n\n                // delete the element from clusterList and pointList\n\n                this.setState(prevState =>{\n                    return {\n                        clusterList: prevState.clusterList.splice( prevState.clusterList.indexOf(this.state.mask[startY][startX]), 1 ),\n                        pointList: prevState.pointList.splice( prevState.clusterList.indexOf(this.state.mask[startY][startX]), 1)\n                    }\n                })\n\n                return\n            }\n\n            // call floodFill method and pass to it initial (x,y) and initial RGBA of the pixel clicked\n            this.floodFill(startX, startY, r, g, b, a, color, this.state.mask, colorImage);\n            redraw();\n\n\n            this.setState(prevState =>{\n                return {\n                    clusterList: prevState.clusterList.push(this.state.mask[startY][startX]),\n                    pointList: prevState.pointList.push([startX, startY])\n                }\n            })\n\n        }\n\n    }\n\n    floodFill(startX, startY, startR, startG, startB, startA, newColor, mask, colorImage){\n\n\n        let newPos,\n            x,\n            y,\n            pixelPos,\n            reachLeft,\n            reachRight,\n            canvasBoundLeft = 0,\n            canvasBoundTop = 0,\n            canvasBoundRight = canvasBoundLeft + this.state.canvasWidth - 1,\n            canvasBoundBottom = canvasBoundTop + this.state.canvasHeight - 1,\n            pixelStack = [[startX, startY]];\n\n\n        this.setState(() =>{\n            return {\n                clusterID: this.state.mask[startY][startX]\n            }\n        });\n\n\n        while (pixelStack.length) {\n\n            newPos = pixelStack.pop();\n            x = newPos[0];\n            y = newPos[1];\n\n            // takes current pixel position\n            pixelPos = (y * this.state.canvasWidth + x) * 4;\n\n            // go up inside the canvas until initialColor matches\n            while (y >= canvasBoundTop && this.matchInitialColor(pixelPos, x, y, startR, startG, startB, startA, newColor, colorImage, mask)) {\n                y -= 1;\n                pixelPos -= this.state.canvasWidth * 4;\n            }\n\n            pixelPos += this.state.canvasWidth * 4;\n            y += 1;\n            reachLeft = false;\n            reachRight = false;\n\n            // go down inside the canvas until initialColor matches\n            while (y <= canvasBoundBottom && this.matchInitialColor(pixelPos, x, y, startR, startG, startB, startA, newColor, colorImage, mask)) {\n                //y += 1;\n\n                this.colorPixel(pixelPos, newColor[0], newColor[1], newColor[2], newColor[3], colorImage);\n\n                if (x > canvasBoundLeft) { //check left side pixel\n                    if (this.matchInitialColor(pixelPos - 4, x - 1, y, startR, startG, startB, startA, newColor, colorImage, mask)) {\n                        if (!reachLeft) {\n                            //aggiungi pixel allo stack\n                            pixelStack.push([x - 1, y]);\n                            reachLeft = true;\n                        }\n                    } else if (reachLeft) {\n                        reachLeft = false;\n                    }\n                }\n\n                if (x < canvasBoundRight) { //check right side pixel\n                    if (this.matchInitialColor(pixelPos + 4, x + 1, y, startR, startG, startB, startA, newColor, colorImage, mask)) {\n                        if (!reachRight) {\n                            //aggiungi pixel allo stack\n                            pixelStack.push([x + 1, y]);\n                            reachRight = true;\n                        }\n                    } else if (reachRight) {\n                        reachRight = false;\n                    }\n                }\n\n                y += 1;\n                pixelPos += this.state.canvasWidth * 4;\n\n            }\n        }\n    }\n\n    matchInitialColor(pixelPos, x, y, startR, startG, startB, startA, newColor, colorImage, mask){\n        let different_cluster = false;\n        console.log(mask[y][x]);\n        console.log(this.state.mask[y][x]);\n        // eslint-disable-next-line\n        if(this.state.mask[y][x] != this.state.clusterID){\n           //console.log(mask[y][x]);\n           different_cluster = true;\n        }\n\n        // check if current pixel is in outline image and has different cluster_id\n        if (this.matchOutlineBorder(pixelPos) && different_cluster){\n            return false;\n        }\n\n\n        let r = colorImage[pixelPos],\n            g = colorImage[pixelPos + 1],\n            b = colorImage[pixelPos + 2],\n            a = colorImage[pixelPos + 3];\n\n        // If the current pixel matches the clicked color\n        // eslint-disable-next-line\n        if (r == startR && g == startG && b == startB && a == startA){\n            return true;\n        }\n\n        // If current pixel color is already colored with new color and opacity\n        // eslint-disable-next-line\n        if (r == newColor[0] && g == newColor[1] && b == newColor[2] && a == newColor[3] ) {\n            return false;\n        }\n\n        return true;\n    }\n\n    colorPixel(pixelPos, r, g, b, a, colorImage) {\n        colorImage[pixelPos] = r;\n        colorImage[pixelPos + 1] = g;\n        colorImage[pixelPos + 2] = b;\n        colorImage[pixelPos + 3] = a !== undefined ? a : 255;\n    }\n\n    matchOutlineBorder(pixelPos){\n\n        const { boundaries } = this.props;\n        let outline_matrix = JSON.parse(boundaries);\n\n        let pixel = outline_matrix[pixelPos];\n\n        return (String(pixel[0]) === '0');\n\n        /*\n        let r = outlineImage[pixelPos],\n            g = outlineImage[pixelPos + 1],\n            b = outlineImage[pixelPos + 2],\n            a = outlineImage[pixelPos + 3];\n\n        return (r === outlineColor[0] && g === outlineColor[1] && b === outlineColor[2] && a == outlineColor[3] );\n         */\n\n    }\n\n    render(){\n        return(\n            <canvas id=\"color\"\n                    ref={this.canvasRef}\n                    style={{ zIndex: 3, position:'absolute'}}\n                    onClick={(event) => this.clickMouse(event)}\n                    onDragStart={(event) => this.dragStart(event)}\n                    onDragOver={(event) => this.dragOver(event)}\n                    onDragEnd={(event) => this.dragEnd(event)} >\n                Sorry, your browser doesn't support the &lt;canvas&gt; element. \n            </canvas> \n        )\n    }\n}\nexport default ColorCanvas;\n\nfunction createColorImage(props) {\n    const {context, size, mask, color} = props;\n    let mask_matrix = JSON.parse(mask);\n\n    // console.log(outline_matrix[0][0]);\n\n    let colorLayerData = context.createImageData(size[0], size[1]);\n    let colorImage = colorLayerData.data;\n    // scroll the matrix with boundaries to create the outline image\n\n    // TODO: colora in base alle annotations\n\n\n    // draw the outline layer in the 3° canvas\n    context.putImageData(colorLayerData, 0, 0);\n\n\n}\n\n\nfunction redraw(){\n\n}"]},"metadata":{},"sourceType":"module"}