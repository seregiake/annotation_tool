{"ast":null,"code":"var _jsxFileName = \"/Users/serenagiachetti/Desktop/projects/annotation_tool/frontend/src/components/ColorCanvas.js\";\nimport React, { Component } from 'react';\n\nclass ColorCanvas extends Component {\n  constructor(props) {\n    super(props);\n    this.canvasRef = React.createRef();\n    this.state = {\n      drawingAreaX: 0,\n      drawingAreaY: 0,\n      clusterID: 0,\n      clusterList: [],\n      pointList: [],\n      draggedPointList: [],\n      draggedMaskPointList: [],\n      mouseDrag: false,\n      curColor: [255, 0, 0],\n      outlineColor: [0, 0, 0, 127]\n    };\n  }\n\n  componentDidMount() {\n    this.updateCanvas();\n  }\n\n  componentDidUpdate() {\n    this.updateCanvas();\n  }\n\n  updateCanvas() {\n    const canvas = this.canvasRef.current;\n    const context = canvas.getContext('2d');\n    const {\n      mask,\n      size,\n      color\n    } = this.props; //console.log(size);\n    // eslint-disable-next-line\n\n    if (mask != undefined && size != undefined && color != undefined) {\n      context.canvas.width = size[0];\n      context.canvas.height = size[1];\n      context.clearRect(0, 0, size[0], size[1]); // draw children “components”\n      // crea colorImage\n      // fai get delle annotazioni esistenti\n      // e disegnale\n\n      createColorImage({\n        context,\n        mask,\n        size,\n        color\n      });\n    }\n  }\n\n  getMousePos(e) {\n    let color_canvas = this.canvasRef.current;\n    let drawingAreaX = color_canvas.getBoundingClientRect().left;\n    let drawingAreaY = color_canvas.getBoundingClientRect().top; // get color_canvas position\n\n    this.setState(prevState => {\n      return {\n        drawingAreaX: drawingAreaX,\n        drawingAreaY: drawingAreaY\n      };\n    }); // mouse click coordinates on the canvas rounded to manage float case\n\n    let mouseX = Math.round(e.pageX - document.body.scrollLeft - document.documentElement.scrollLeft - drawingAreaX),\n        mouseY = Math.round(e.pageY - document.body.scrollTop - document.documentElement.scrollTop - drawingAreaY);\n    return [mouseX, mouseY];\n  }\n\n  clickMouse(event) {\n    let [x, y] = this.getMousePos(event);\n    console.log(\"x: \" + x + \", y: \" + y); //paintAt(x, y);\n  }\n\n  dragStart(event) {//TODO\n  }\n\n  dragOver(event) {//TODO\n  }\n\n  dragEnd(event) {//TODO\n  }\n\n  paintAt(startX, startY) {\n    const {\n      size,\n      color,\n      mask\n    } = this.props;\n    let mask_matrix = JSON.parse(mask);\n    const canvas = this.canvasRef.current;\n    const context = canvas.getContext('2d'); // eslint-disable-next-line\n\n    if (size != undefined && color != undefined) {\n      let colorImage = context.getImageData(0, 0, size[0], size[1]).data; // takes pixel RGBA color\n\n      let pixelPos = (startY * size[0] + startX) * 4,\n          r = colorImage[pixelPos],\n          g = colorImage[pixelPos + 1],\n          b = colorImage[pixelPos + 2],\n          a = colorImage[pixelPos + 3]; // return if you try to recolor the area with the same color and the same opacity\n\n      if (r == color[0] && g == color[1] && b == color[2] && a == color[3]) {\n        floodFill(startX, startY, r, g, b, a, [0, 0, 0, 0]);\n        redraw(); // delete the element from clusterList and pointList\n\n        this.setState(prevState => {\n          return {\n            clusterList: prevState.clusterList.splice(prevState.clusterList.indexOf(mask_matrix[startY][startX]), 1),\n            pointList: prevState.pointList.splice(prevState.clusterList.indexOf(mask_matrix[startY][startX]), 1)\n          };\n        });\n        return;\n      } // call floodFill method and pass to it initial (x,y) and initial RGBA of the pixel clicked\n\n\n      floodFill(startX, startY, r, g, b, a, color);\n      redraw();\n      this.setState(prevState => {\n        return {\n          clusterList: prevState.clusterList.push(mask_matrix[startY][startX]),\n          pointList: prevState.pointList.push([startX, startY])\n        };\n      });\n    }\n  }\n\n  render() {\n    return React.createElement(\"canvas\", {\n      id: \"color\",\n      ref: this.canvasRef,\n      style: {\n        zIndex: 3,\n        position: 'absolute',\n        backgroundColor: 'rgba(255,0,0,0.45)'\n      },\n      onClick: event => this.clickMouse(event),\n      onDragStart: event => this.dragStart(event),\n      onDragOver: event => this.dragOver(event),\n      onDragEnd: event => this.dragEnd(event),\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 149\n      },\n      __self: this\n    }, \"Sorry, your browser doesn't support the <canvas> element.\");\n  }\n\n}\n\nexport default ColorCanvas;\n\nfunction createColorImage(props) {\n  const {\n    context,\n    size,\n    mask,\n    color\n  } = props;\n  let mask_matrix = JSON.parse(mask); // console.log(outline_matrix[0][0]);\n\n  let colorLayerData = context.createImageData(size[0], size[1]);\n  let colorImage = colorLayerData.data; // scroll the matrix with boundaries to create the outline image\n  // TODO: colora in base alle annotations\n  // draw the outline layer in the 3° canvas\n\n  context.putImageData(colorLayerData, 0, 0);\n}","map":{"version":3,"sources":["/Users/serenagiachetti/Desktop/projects/annotation_tool/frontend/src/components/ColorCanvas.js"],"names":["React","Component","ColorCanvas","constructor","props","canvasRef","createRef","state","drawingAreaX","drawingAreaY","clusterID","clusterList","pointList","draggedPointList","draggedMaskPointList","mouseDrag","curColor","outlineColor","componentDidMount","updateCanvas","componentDidUpdate","canvas","current","context","getContext","mask","size","color","undefined","width","height","clearRect","createColorImage","getMousePos","e","color_canvas","getBoundingClientRect","left","top","setState","prevState","mouseX","Math","round","pageX","document","body","scrollLeft","documentElement","mouseY","pageY","scrollTop","clickMouse","event","x","y","console","log","dragStart","dragOver","dragEnd","paintAt","startX","startY","mask_matrix","JSON","parse","colorImage","getImageData","data","pixelPos","r","g","b","a","floodFill","redraw","splice","indexOf","push","render","zIndex","position","backgroundColor","colorLayerData","createImageData","putImageData"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\nclass ColorCanvas extends Component {\n\n    constructor (props){\n        super(props);\n        this.canvasRef = React.createRef();\n        this.state = {\n            drawingAreaX: 0,\n            drawingAreaY: 0,\n            clusterID: 0,\n            clusterList: [],\n            pointList: [],\n            draggedPointList: [],\n            draggedMaskPointList: [],\n            mouseDrag: false,\n            curColor: [255, 0, 0],\n            outlineColor: [0, 0, 0, 127]\n\n        }\n    }\n\n    componentDidMount() {\n        this.updateCanvas();\n    }\n\n    componentDidUpdate() {\n        this.updateCanvas();\n    }\n\n    updateCanvas() {\n        const canvas = this.canvasRef.current;\n        const context = canvas.getContext('2d');\n        const { mask, size, color } = this.props;\n\n        //console.log(size);\n        // eslint-disable-next-line\n        if (mask != undefined && size != undefined && color != undefined){\n            context.canvas.width = size[0];\n            context.canvas.height = size[1];\n            context.clearRect(0,0, size[0], size[1]);\n\n            // draw children “components”\n            // crea colorImage\n            // fai get delle annotazioni esistenti\n            // e disegnale\n            createColorImage({context, mask, size, color});\n\n        }\n    }\n\n    getMousePos(e){\n       let color_canvas = this.canvasRef.current;\n\n       let drawingAreaX = color_canvas.getBoundingClientRect().left;\n       let drawingAreaY = color_canvas.getBoundingClientRect().top;\n\n        // get color_canvas position\n        this.setState(prevState =>{\n            return {\n                drawingAreaX: drawingAreaX,\n                drawingAreaY: drawingAreaY\n            }\n        })\n\n        // mouse click coordinates on the canvas rounded to manage float case\n        let mouseX = Math.round(e.pageX - document.body.scrollLeft - document.documentElement.scrollLeft - drawingAreaX),\n            mouseY = Math.round(e.pageY - document.body.scrollTop - document.documentElement.scrollTop - drawingAreaY);\n\n        return [mouseX, mouseY];\n    }\n\n    clickMouse(event){\n        let [x, y] = this.getMousePos(event);\n\n        console.log(\"x: \" + x + \", y: \" + y);\n\n        //paintAt(x, y);\n\n    }\n\n    dragStart(event){\n        //TODO\n    }\n\n    dragOver(event){\n        //TODO\n    }\n\n    dragEnd(event){\n        //TODO\n    }\n\n    paintAt(startX, startY){\n        const { size, color, mask } = this.props;\n        let mask_matrix = JSON.parse(mask);\n        const canvas = this.canvasRef.current;\n        const context = canvas.getContext('2d');\n\n        // eslint-disable-next-line\n        if(size != undefined && color != undefined){\n\n            let colorImage = context.getImageData(0,0, size[0], size[1]).data;\n\n            // takes pixel RGBA color\n            let pixelPos = (startY * size[0] + startX) * 4,\n                r = colorImage[pixelPos],\n                g = colorImage[pixelPos + 1],\n                b = colorImage[pixelPos + 2],\n                a = colorImage[pixelPos + 3];\n\n            // return if you try to recolor the area with the same color and the same opacity\n            if (r == color[0] && g == color[1] && b == color[2] && a == color[3]){\n\n                floodFill(startX, startY, r, g, b, a, [0, 0, 0, 0]);\n                redraw();\n\n                // delete the element from clusterList and pointList\n\n                this.setState(prevState =>{\n                    return {\n                        clusterList: prevState.clusterList.splice( prevState.clusterList.indexOf(mask_matrix[startY][startX]), 1 ),\n                        pointList: prevState.pointList.splice( prevState.clusterList.indexOf(mask_matrix[startY][startX]), 1)\n                    }\n                })\n\n                return\n            }\n\n            // call floodFill method and pass to it initial (x,y) and initial RGBA of the pixel clicked\n            floodFill(startX, startY, r, g, b, a, color);\n            redraw();\n\n\n            this.setState(prevState =>{\n                return {\n                    clusterList: prevState.clusterList.push(mask_matrix[startY][startX]),\n                    pointList: prevState.pointList.push([startX, startY])\n                }\n            })\n\n        }\n\n    }\n\n\n    \n   render() {\n        return(\n            <canvas id=\"color\"\n                    ref={this.canvasRef}\n                    style={{ zIndex: 3, position:'absolute', backgroundColor:'rgba(255,0,0,0.45)'}}\n                    onClick={(event) => this.clickMouse(event)}\n                    onDragStart={(event) => this.dragStart(event)}\n                    onDragOver={(event) => this.dragOver(event)}\n                    onDragEnd={(event) => this.dragEnd(event)}\n\n            >\n                Sorry, your browser doesn't support the &lt;canvas&gt; element. \n            </canvas> \n        )\n\n    \n    \n    \n    }\n    \n}\nexport default ColorCanvas;\n\nfunction createColorImage(props) {\n    const {context, size, mask, color} = props;\n    let mask_matrix = JSON.parse(mask);\n\n    // console.log(outline_matrix[0][0]);\n\n    let colorLayerData = context.createImageData(size[0], size[1]);\n    let colorImage = colorLayerData.data;\n    // scroll the matrix with boundaries to create the outline image\n\n    // TODO: colora in base alle annotations\n\n\n    // draw the outline layer in the 3° canvas\n    context.putImageData(colorLayerData, 0, 0);\n\n\n}"]},"metadata":{},"sourceType":"module"}